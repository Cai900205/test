From: Vladimir Sokolovsky <vlad@mellanox.com>
Subject: [PATCH] BACKPORT: ib_iser

Signed-off-by: Vladimir Sokolovsky <vlad@mellanox.com>
Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
Signed-off-by: Roi Dayan <roid@mellanox.com>
---
 drivers/infiniband/ulp/iser/iscsi_iser.c     |   80 +++++++++++++++++++++++---
 drivers/infiniband/ulp/iser/iscsi_iser.h     |   36 +++++++++++-
 drivers/infiniband/ulp/iser/iser_initiator.c |   78 +++++++++++++++++++++++++
 drivers/infiniband/ulp/iser/iser_memory.c    |   35 ++++++++++-
 drivers/infiniband/ulp/iser/iser_verbs.c     |   44 +++++++++++++-
 5 files changed, 257 insertions(+), 16 deletions(-)

diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.c b/drivers/infiniband/ulp/iser/iscsi_iser.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/infiniband/ulp/iser/iscsi_iser.c
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.c
@@ -81,23 +81,24 @@ static struct scsi_transport_template *iscsi_iser_scsi_transport;
 static unsigned int iscsi_max_lun = 512;
 module_param_named(max_lun, iscsi_max_lun, uint, S_IRUGO);
 
-int iser_debug_level = 0;
-bool iser_pi_enable = false;
-int iser_pi_guard = 0;
-
 MODULE_DESCRIPTION("iSER (iSCSI Extensions for RDMA) Datamover");
 MODULE_LICENSE("Dual BSD/GPL");
 MODULE_AUTHOR("Alex Nezhinsky, Dan Bar Dov, Or Gerlitz");
 MODULE_VERSION(DRV_VER);
 
+int iser_debug_level = 0;
 module_param_named(debug_level, iser_debug_level, int, 0644);
 MODULE_PARM_DESC(debug_level, "Enable debug tracing if > 0 (default:disabled)");
 
+#if defined(CONFIG_COMPAT_SIGNATURE)
+bool iser_pi_enable = false;
 module_param_named(pi_enable, iser_pi_enable, bool, 0644);
 MODULE_PARM_DESC(pi_enable, "Enable T10-PI offload support (default:disabled)");
 
+int iser_pi_guard = 0;
 module_param_named(pi_guard, iser_pi_guard, int, 0644);
 MODULE_PARM_DESC(pi_guard, "T10-PI guard_type, 0:CRC|1:IP_CSUM (default:CRC)");
+#endif
 
 int iser_cq_completions;
 module_param_named(cq_completions, iser_cq_completions, int, 0644);
@@ -318,6 +319,7 @@ static void iscsi_iser_cleanup_task(struct iscsi_task *task)
 	}
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 static u8 iscsi_iser_check_protection(struct iscsi_task *task, sector_t *sector)
 {
 	struct iscsi_iser_task *iser_task = task->dd_data;
@@ -329,6 +331,7 @@ static u8 iscsi_iser_check_protection(struct iscsi_task *task, sector_t *sector)
 		return iser_check_task_pi_status(iser_task, ISER_DIR_OUT,
 						 sector);
 }
+#endif
 
 static struct iscsi_cls_conn *
 iscsi_iser_conn_create(struct iscsi_cls_session *cls_session, uint32_t conn_idx)
@@ -401,6 +404,13 @@ out:
 	return ret;
 }
 
+#if !defined(CONFIG_COMPAT_IS_REINIT_COMPLETION)
+static inline void reinit_completion(struct completion *x)
+{
+	x->done = 0;
+}
+#endif
+
 static int
 iscsi_iser_conn_start(struct iscsi_cls_conn *cls_conn)
 {
@@ -452,6 +462,7 @@ static void iscsi_iser_session_destroy(struct iscsi_cls_session *cls_session)
 	iscsi_host_free(shost);
 }
 
+#if defined(CONFIG_COMPAT_SIGNATURE)
 static inline unsigned int
 iser_dif_prot_caps(int prot_caps)
 {
@@ -462,6 +473,7 @@ iser_dif_prot_caps(int prot_caps)
 	       ((prot_caps & IB_PROT_T10DIF_TYPE_3) ? SHOST_DIF_TYPE3_PROTECTION |
 						      SHOST_DIX_TYPE3_PROTECTION : 0);
 }
+#endif
 
 static struct iscsi_cls_session *
 iscsi_iser_session_create(struct iscsi_endpoint *ep,
@@ -489,6 +501,7 @@ iscsi_iser_session_create(struct iscsi_endpoint *ep,
 	 */
 	if (ep) {
 		ib_conn = ep->dd_data;
+#if defined(CONFIG_COMPAT_SIGNATURE)
 		if (ib_conn->pi_support) {
 			u32 sig_caps = ib_conn->device->dev_attr.sig_prot_cap;
 
@@ -498,6 +511,7 @@ iscsi_iser_session_create(struct iscsi_endpoint *ep,
 			else
 				scsi_host_set_guard(shost, SHOST_DIX_GUARD_CRC);
 		}
+#endif
 	}
 
 	if (iscsi_host_add(shost,
@@ -598,6 +612,7 @@ iscsi_iser_conn_get_stats(struct iscsi_cls_conn *cls_conn, struct iscsi_stats *s
 	stats->custom[3].value = conn->fmr_unalign_cnt;
 }
 
+#ifdef CONFIG_COMPAT_ISCSI_ISER_GET_EP_PARAM
 static int iscsi_iser_get_ep_param(struct iscsi_endpoint *ep,
 				   enum iscsi_param param, char *buf)
 {
@@ -628,6 +643,7 @@ static int iscsi_iser_get_ep_param(struct iscsi_endpoint *ep,
 
 	return len;
 }
+#endif
 
 static struct iscsi_endpoint *
 iscsi_iser_ep_connect(struct Scsi_Host *shost, struct sockaddr *dst_addr,
@@ -740,7 +756,12 @@ destroy_ep:
 	iscsi_destroy_endpoint(ep);
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0))
 static umode_t iser_attr_is_visible(int param_type, int param)
+#elif defined(CONFIG_COMPAT_ISER_ATTR_IS_VISIBLE)
+static mode_t iser_attr_is_visible(int param_type, int param)
+#endif
+#ifdef CONFIG_COMPAT_ISER_ATTR_IS_VISIBLE
 {
 	switch (param_type) {
 	case ISCSI_HOST_PARAM:
@@ -784,7 +805,9 @@ static umode_t iser_attr_is_visible(int param_type, int param)
 		case ISCSI_PARAM_TGT_RESET_TMO:
 		case ISCSI_PARAM_IFACE_NAME:
 		case ISCSI_PARAM_INITIATOR_NAME:
+#if defined(CONFIG_ISER_DISCOVERY)
 		case ISCSI_PARAM_DISCOVERY_SESS:
+#endif
 			return S_IRUGO;
 		default:
 			return 0;
@@ -793,6 +816,7 @@ static umode_t iser_attr_is_visible(int param_type, int param)
 
 	return 0;
 }
+#endif
 
 static struct scsi_host_template iscsi_iser_sht = {
 	.module                 = THIS_MODULE,
@@ -804,7 +828,11 @@ static struct scsi_host_template iscsi_iser_sht = {
 	.cmd_per_lun            = ISER_DEF_CMD_PER_LUN,
 	.eh_abort_handler       = iscsi_eh_abort,
 	.eh_device_reset_handler= iscsi_eh_device_reset,
+#if defined(CONFIG_COMPAT_ISCSI_EH_TARGET_RESET)
+	.eh_target_reset_handler = iscsi_eh_target_reset,
+#else
 	.eh_target_reset_handler = iscsi_eh_recover_target,
+#endif
 	.target_alloc		= iscsi_target_alloc,
 	.use_clustering         = DISABLE_CLUSTERING,
 	.proc_name              = "iscsi_iser",
@@ -815,8 +843,38 @@ static struct iscsi_transport iscsi_iser_transport = {
 	.owner                  = THIS_MODULE,
 	.name                   = "iser",
 	.caps                   = CAP_RECOVERY_L0 |
+#if defined(CONFIG_ISER_DISCOVERY)
 				  CAP_MULTI_R2T |
 				  CAP_TEXT_NEGO,
+#else
+				  CAP_MULTI_R2T,
+#endif
+#if defined(CONFIG_COMPAT_ISCSI_TRANSPORT_PARAM_MASK)
+        .param_mask             = ISCSI_MAX_RECV_DLENGTH |
+                                  ISCSI_MAX_XMIT_DLENGTH |
+                                  ISCSI_HDRDGST_EN |
+                                  ISCSI_DATADGST_EN |
+                                  ISCSI_INITIAL_R2T_EN |
+                                  ISCSI_MAX_R2T |
+                                  ISCSI_IMM_DATA_EN |
+                                  ISCSI_FIRST_BURST |
+                                  ISCSI_MAX_BURST |
+                                  ISCSI_PDU_INORDER_EN |
+                                  ISCSI_DATASEQ_INORDER_EN |
+                                  ISCSI_EXP_STATSN |
+                                  ISCSI_PERSISTENT_PORT |
+                                  ISCSI_PERSISTENT_ADDRESS |
+                                  ISCSI_TARGET_NAME | ISCSI_TPGT |
+                                  ISCSI_USERNAME | ISCSI_PASSWORD |
+                                  ISCSI_USERNAME_IN | ISCSI_PASSWORD_IN |
+                                  ISCSI_FAST_ABORT | ISCSI_ABORT_TMO |
+                                  ISCSI_LU_RESET_TMO | ISCSI_TGT_RESET_TMO |
+                                  ISCSI_PING_TMO | ISCSI_RECV_TMO |
+                                  ISCSI_IFACE_NAME | ISCSI_INITIATOR_NAME,
+        .host_param_mask        = ISCSI_HOST_HWADDRESS |
+                                  ISCSI_HOST_NETDEV_NAME |
+                                  ISCSI_HOST_INITIATOR_NAME,
+#endif
 	/* session management */
 	.create_session         = iscsi_iser_session_create,
 	.destroy_session        = iscsi_iser_session_destroy,
@@ -824,10 +882,14 @@ static struct iscsi_transport iscsi_iser_transport = {
 	.create_conn            = iscsi_iser_conn_create,
 	.bind_conn              = iscsi_iser_conn_bind,
 	.destroy_conn           = iscsi_conn_teardown,
-	.attr_is_visible	= iser_attr_is_visible,
+#ifdef CONFIG_COMPAT_ISER_ATTR_IS_VISIBLE
+ 	.attr_is_visible	= iser_attr_is_visible,
+#endif
 	.set_param              = iscsi_iser_set_param,
 	.get_conn_param		= iscsi_conn_get_param,
-	.get_ep_param		= iscsi_iser_get_ep_param,
+#ifdef CONFIG_COMPAT_ISCSI_ISER_GET_EP_PARAM
+ 	.get_ep_param		= iscsi_iser_get_ep_param,
+#endif
 	.get_session_param	= iscsi_session_get_param,
 	.start_conn             = iscsi_iser_conn_start,
 	.stop_conn              = iscsi_iser_conn_stop,
@@ -841,7 +903,9 @@ static struct iscsi_transport iscsi_iser_transport = {
 	.xmit_task		= iscsi_iser_task_xmit,
 	.cleanup_task		= iscsi_iser_cleanup_task,
 	.alloc_pdu		= iscsi_iser_pdu_alloc,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 	.check_protection	= iscsi_iser_check_protection,
+#endif
 	/* recovery */
 	.session_recovery_timedout = iscsi_session_recovery_timedout,
 
@@ -866,12 +930,12 @@ static int __init iser_init(void)
 			 iser_cq_poll_limit);
 		return -EINVAL;
 	}
-
+#if defined(CONFIG_COMPAT_SIGNATURE)
 	if (iser_pi_guard < 0 || iser_pi_guard > 1) {
 		iser_err("Invalid pi_guard value of %d\n", iser_pi_guard);
 		return -EINVAL;
 	}
-
+#endif
 	memset(&ig, 0, sizeof(struct iser_global));
 
 	ig.desc_cache = kmem_cache_create("iser_descriptors",
diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.h b/drivers/infiniband/ulp/iser/iscsi_iser.h
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/infiniband/ulp/iser/iscsi_iser.h
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.h
@@ -41,6 +41,7 @@
 #ifndef __ISCSI_ISER_H__
 #define __ISCSI_ISER_H__
 
+#include <linux/version.h>
 #include <linux/types.h>
 #include <linux/net.h>
 #include <linux/printk.h>
@@ -72,6 +73,36 @@
 #define PFX		DRV_NAME ": "
 #define DRV_VER		"1.4.5"
 
+#if !defined(CONFIG_COMPAT_SIGNATURE)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0)
+#define CONFIG_COMPAT_SIGNATURE
+#endif
+#endif
+
+#if !defined(CONFIG_COMPAT_IS_REINIT_COMPLETION)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,13,0)
+#define CONFIG_COMPAT_IS_REINIT_COMPLETION
+#endif
+#endif
+
+#if !defined(CONFIG_COMPAT_ISCSI_ISER_GET_EP_PARAM)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)
+#define CONFIG_COMPAT_ISCSI_ISER_GET_EP_PARAM
+#endif
+#endif
+
+#if !defined(CONFIG_COMPAT_ISER_ATTR_IS_VISIBLE)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0)
+#define CONFIG_COMPAT_ISER_ATTR_IS_VISIBLE
+#endif
+#endif
+
+#if !defined(CONFIG_COMPAT_IF_ISCSI_SCSI_REQ)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,1,0)
+#define CONFIG_COMPAT_IF_ISCSI_SCSI_REQ
+#endif
+#endif
+
 #define iser_dbg(fmt, arg...)				\
 	do {						\
 		if (iser_debug_level > 2)		\
@@ -313,7 +344,9 @@ struct fast_reg_descriptor {
 	/* For fast registration - FRWR */
 	struct ib_mr			 *data_mr;
 	struct ib_fast_reg_page_list     *data_frpl;
+#if defined(CONFIG_COMPAT_SIGNATURE)
 	struct iser_pi_context		 *pi_ctx;
+#endif /* CONFIG_COMPAT_SIGNATURE */
 	/* registration indicators container */
 	u8				  reg_indicators;
 };
@@ -348,7 +381,6 @@ struct iser_conn {
 	struct iser_rx_desc	     *rx_descs;
 	struct ib_recv_wr	     rx_wr[ISER_MIN_POSTED_RX];
 	bool			     pi_support;
-
 	/* Connection memory registration pool */
 	union {
 		struct {
@@ -494,6 +526,8 @@ int iser_create_fmr_pool(struct iser_conn *ib_conn, unsigned cmds_max);
 void iser_free_fmr_pool(struct iser_conn *ib_conn);
 int iser_create_fastreg_pool(struct iser_conn *ib_conn, unsigned cmds_max);
 void iser_free_fastreg_pool(struct iser_conn *ib_conn);
+#if defined(CONFIG_COMPAT_SIGNATURE)
 u8 iser_check_task_pi_status(struct iscsi_iser_task *iser_task,
 			     enum iser_data_dir cmd_dir, sector_t *sector);
+#endif /* CONFIG_COMPAT_SIGNATURE */
 #endif
diff --git a/drivers/infiniband/ulp/iser/iser_initiator.c b/drivers/infiniband/ulp/iser/iser_initiator.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/infiniband/ulp/iser/iser_initiator.c
+++ b/drivers/infiniband/ulp/iser/iser_initiator.c
@@ -335,7 +335,9 @@ free_login_buf:
 static int iser_post_rx_bufs(struct iscsi_conn *conn, struct iscsi_hdr *req)
 {
 	struct iser_conn *ib_conn = conn->dd_data;
+#if defined(CONFIG_ISER_DISCOVERY)
 	struct iscsi_session *session = conn->session;
+#endif
 
 	iser_dbg("req op %x flags %x\n", req->opcode, req->flags);
 	/* check if this is the last login - going to full feature phase */
@@ -350,12 +352,14 @@ static int iser_post_rx_bufs(struct iscsi_conn *conn, struct iscsi_hdr *req)
 	WARN_ON(ib_conn->post_recv_buf_count != 1);
 	WARN_ON(atomic_read(&ib_conn->post_send_buf_count) != 0);
 
+#if defined(CONFIG_ISER_DISCOVERY)
 	if (session->discovery_sess) {
 		iser_info("Discovery session, re-using login RX buffer\n");
 		return 0;
 	} else
 		iser_info("Normal session, posting batch of RX %d buffers\n",
 			  ib_conn->min_posted_rx);
+#endif
 
 	/* Initial post receive buffers */
 	if (iser_post_recvm(ib_conn, ib_conn->min_posted_rx))
@@ -364,6 +368,24 @@ static int iser_post_rx_bufs(struct iscsi_conn *conn, struct iscsi_hdr *req)
 	return 0;
 }
 
+#if  (LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0))
+static inline unsigned scsi_transfer_length(struct scsi_cmnd *scmd)
+{
+	unsigned int xfer_len = scsi_bufflen(scmd);
+	unsigned int prot_op = scsi_get_prot_op(scmd);
+	unsigned int sector_size = scmd->device->sector_size;
+
+	switch (prot_op) {
+	case SCSI_PROT_NORMAL:
+	case SCSI_PROT_WRITE_STRIP:
+	case SCSI_PROT_READ_INSERT:
+		return xfer_len;
+	}
+
+	return xfer_len + (xfer_len >> ilog2(sector_size)) * 8;
+}
+#endif
+
 /**
  * iser_send_command - send command PDU
  */
@@ -375,11 +397,21 @@ int iser_send_command(struct iscsi_conn *conn,
 	unsigned long edtl;
 	int err;
 	struct iser_data_buf *data_buf, *prot_buf;
+#ifdef CONFIG_COMPAT_IF_ISCSI_SCSI_REQ
 	struct iscsi_scsi_req *hdr = (struct iscsi_scsi_req *)task->hdr;
+#else
+	struct iscsi_cmd *hdr =  (struct iscsi_cmd *)task->hdr;
+#endif
 	struct scsi_cmnd *sc  =  task->sc;
 	struct iser_tx_desc *tx_desc = &iser_task->desc;
 
 	edtl = ntohl(hdr->data_length);
+#if  (LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0))
+ 	if (scsi_get_prot_op(sc) != SCSI_PROT_NORMAL) {
+		edtl = scsi_transfer_length(sc);
+ 		hdr->data_length = cpu_to_be32(edtl);
+ 	}
+#endif
 
 	/* build the tx desc regd header and add it to the tx desc dto */
 	tx_desc->type = ISCSI_TX_SCSI_COMMAND;
@@ -559,6 +591,46 @@ send_control_error:
 	return err;
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)) && defined(CONFIG_COMPAT_SIGNATURE)
+static void iser_check_protection(struct iscsi_conn *conn,
+				  struct iscsi_hdr *hdr)
+{
+	struct iscsi_task *task;
+	struct iscsi_iser_task *iser_task;
+	struct scsi_cmnd *sc;
+	enum iser_data_dir dir;
+	sector_t sector;
+	u8 ascq;
+
+#ifndef CONFIG_COMPAT_ISCSI_SESSION_FRWD_LOCK
+	spin_lock(&conn->session->lock);
+	task = iscsi_itt_to_ctask(conn, hdr->itt);
+	spin_unlock(&conn->session->lock);
+#else
+	spin_lock(&conn->session->back_lock);
+	task = iscsi_itt_to_ctask(conn, hdr->itt);
+	spin_unlock(&conn->session->back_lock);
+#endif
+	sc = task->sc;
+	iser_task = task->dd_data;
+
+	dir = iser_task->dir[ISER_DIR_IN] ? ISER_DIR_IN : ISER_DIR_OUT;
+	ascq = iser_check_task_pi_status(iser_task, dir, &sector);
+	if (ascq) {
+		sc->result = DRIVER_SENSE << 24 | DID_ABORT << 16 |
+			     SAM_STAT_CHECK_CONDITION;
+		scsi_build_sense_buffer(1, sc->sense_buffer,
+					ILLEGAL_REQUEST, 0x10, ascq);
+		sc->sense_buffer[7] = 0xc; /* Additional sense length */
+		sc->sense_buffer[8] = 0;   /* Information desc type */
+		sc->sense_buffer[9] = 0xa; /* Additional desc length */
+		sc->sense_buffer[10] = 0x80; /* Validity bit */
+
+		put_unaligned_be64(sector, &sc->sense_buffer[12]);
+	}
+}
+#endif
+
 /**
  * iser_rcv_dto_completion - recv DTO completion
  */
@@ -587,6 +659,12 @@ void iser_rcv_completion(struct iser_rx_desc *rx_desc,
 	iser_dbg("op 0x%x itt 0x%x dlen %d\n", hdr->opcode,
 			hdr->itt, (int)(rx_xfer_len - ISER_HEADERS_LEN));
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)) && defined(CONFIG_COMPAT_SIGNATURE)
+	if (hdr->opcode == ISCSI_OP_SCSI_CMD_RSP &&
+	    ib_conn->pi_support)
+		iser_check_protection(ib_conn->iscsi_conn, hdr);
+#endif
+
 	iscsi_iser_recv(ib_conn->iscsi_conn, hdr, rx_desc->data,
 			rx_xfer_len - ISER_HEADERS_LEN);
 
diff --git a/drivers/infiniband/ulp/iser/iser_memory.c b/drivers/infiniband/ulp/iser/iser_memory.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/infiniband/ulp/iser/iser_memory.c
+++ b/drivers/infiniband/ulp/iser/iser_memory.c
@@ -39,7 +39,11 @@
 
 #include "iscsi_iser.h"
 
-#define ISER_KMALLOC_THRESHOLD 0x20000 /* 128K - kmalloc limit */
+#if  (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32))
+	#define ISER_KMALLOC_THRESHOLD 0x80000 /* 512K - kmalloc limit */
+#else
+	#define ISER_KMALLOC_THRESHOLD 0x20000 /* 128K - kmalloc limit */
+#endif
 
 /**
  * iser_start_rdma_unaligned_sg
@@ -79,11 +83,19 @@ static int iser_start_rdma_unaligned_sg(struct iscsi_iser_task *iser_task,
 		sgl = (struct scatterlist *)data->buf;
 		p = mem;
 		for_each_sg(sgl, sg, data->size, i) {
+#if  (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
 			from = kmap_atomic(sg_page(sg));
+#else
+			from = kmap_atomic(sg_page(sg), KM_USER0);
+#endif
 			memcpy(p,
 			       from + sg->offset,
 			       sg->length);
+#if  (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
 			kunmap_atomic(from);
+#else
+			kunmap_atomic(from, KM_USER0);
+#endif
 			p += sg->length;
 		}
 	}
@@ -137,11 +149,19 @@ void iser_finalize_rdma_unaligned_sg(struct iscsi_iser_task *iser_task,
 
 		p = mem;
 		for_each_sg(sgl, sg, sg_size, i) {
+#if  (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
 			to = kmap_atomic(sg_page(sg));
+#else
+			to = kmap_atomic(sg_page(sg), KM_USER0);
+#endif
 			memcpy(to + sg->offset,
 			       p,
 			       sg->length);
+#if  (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
 			kunmap_atomic(to);
+#else
+			kunmap_atomic(to, KM_USER0);
+#endif
 			p += sg->length;
 		}
 	}
@@ -440,6 +460,7 @@ int iser_reg_rdma_mem_fmr(struct iscsi_iser_task *iser_task,
 	return 0;
 }
 
+#if defined(CONFIG_COMPAT_SIGNATURE)
 static inline enum ib_t10_dif_type
 scsi2ib_prot_type(unsigned char prot_type)
 {
@@ -603,6 +624,7 @@ iser_reg_sig_mr(struct iscsi_iser_task *iser_task,
 err:
 	return ret;
 }
+#endif /* CONFIG_COMPAT_SIGNATURE */
 
 static int iser_fast_reg_mr(struct iscsi_iser_task *iser_task,
 			    struct iser_regd_buf *regd_buf,
@@ -634,6 +656,7 @@ static int iser_fast_reg_mr(struct iscsi_iser_task *iser_task,
 		return 0;
 	}
 
+#if defined(CONFIG_COMPAT_SIGNATURE)
 	if (ind == ISER_DATA_KEY_VALID) {
 		mr = desc->data_mr;
 		frpl = desc->data_frpl;
@@ -641,7 +664,10 @@ static int iser_fast_reg_mr(struct iscsi_iser_task *iser_task,
 		mr = desc->pi_ctx->prot_mr;
 		frpl = desc->pi_ctx->prot_frpl;
 	}
-
+#else
+	mr = desc->data_mr;
+	frpl = desc->data_frpl;
+#endif
 	plen = iser_sg_to_page_vec(mem, device->ib_device, frpl->page_list,
 				   &offset, &size);
 	if (plen * SIZE_4K < size) {
@@ -739,6 +765,7 @@ int iser_reg_rdma_mem_fastreg(struct iscsi_iser_task *iser_task,
 	if (err)
 		goto err_reg;
 
+#if defined(CONFIG_COMPAT_SIGNATURE)
 	if (scsi_get_prot_op(iser_task->sc) != SCSI_PROT_NORMAL) {
 		struct ib_sge prot_sge, sig_sge;
 
@@ -777,6 +804,7 @@ int iser_reg_rdma_mem_fastreg(struct iscsi_iser_task *iser_task,
 		regd_buf->reg.len = sig_sge.length;
 		regd_buf->reg.is_mr = 1;
 	} else {
+#endif
 		if (desc) {
 			regd_buf->reg.rkey = desc->data_mr->rkey;
 			regd_buf->reg.is_mr = 1;
@@ -788,8 +816,9 @@ int iser_reg_rdma_mem_fastreg(struct iscsi_iser_task *iser_task,
 		regd_buf->reg.lkey = data_sge.lkey;
 		regd_buf->reg.va = data_sge.addr;
 		regd_buf->reg.len = data_sge.length;
+#if defined(CONFIG_COMPAT_SIGNATURE)
 	}
-
+#endif
 	return 0;
 err_reg:
 	if (desc) {
diff --git a/drivers/infiniband/ulp/iser/iser_verbs.c b/drivers/infiniband/ulp/iser/iser_verbs.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/infiniband/ulp/iser/iser_verbs.c
+++ b/drivers/infiniband/ulp/iser/iser_verbs.c
@@ -146,15 +146,22 @@ static int iser_create_device_ib_res(struct iser_device *device)
 			goto cq_err;
 
                 if (iser_cq_completions && iser_cq_timeout) {
+#if defined(LINUX_3_0_COMPAT_H) /* MLNX_OFED */
 			struct ib_cq_attr  attr;
 
 			memset(&attr, 0, sizeof(attr));
 			attr.moderation.cq_count = iser_cq_completions;
 			attr.moderation.cq_period = iser_cq_timeout;
-
+#endif
 			iser_info("applying CQ moderation - to be max {%d completions, %d us timeout}\n",
 				  iser_cq_completions, iser_cq_timeout);
+#if defined(LINUX_3_0_COMPAT_H) /* MLNX_OFED */
 			ret = ib_modify_cq(device->rx_cq[i], &attr, IB_CQ_MODERATION);
+#else
+			ret = ib_modify_cq(device->rx_cq[i],
+					   iser_cq_completions,
+					   iser_cq_timeout);
+#endif
 			if (ret == -ENOSYS)
 				iser_err("device does not support CQ moderation\n");
 			else if (ret)
@@ -318,7 +325,7 @@ iser_create_fastreg_desc(struct ib_device *ib_device, struct ib_pd *pd,
 		goto fast_reg_mr_failure;
 	}
 	desc->reg_indicators |= ISER_DATA_KEY_VALID;
-
+#if defined(CONFIG_COMPAT_SIGNATURE)
 	if (pi_enable) {
 		struct ib_mr_init_attr mr_init_attr = {0};
 		struct iser_pi_context *pi_ctx = NULL;
@@ -362,11 +369,12 @@ iser_create_fastreg_desc(struct ib_device *ib_device, struct ib_pd *pd,
 		desc->reg_indicators |= ISER_SIG_KEY_VALID;
 	}
 	desc->reg_indicators &= ~ISER_FASTREG_PROTECTED;
-
+#endif /* CONFIG_COMPAT_SIGNATURE */
 	iser_dbg("Create fr_desc %p page_list %p\n",
 		 desc, desc->data_frpl->page_list);
 
 	return 0;
+#if defined(CONFIG_COMPAT_SIGNATURE)
 sig_mr_failure:
 	ib_dereg_mr(desc->pi_ctx->prot_mr);
 prot_mr_failure:
@@ -375,6 +383,7 @@ prot_frpl_failure:
 	kfree(desc->pi_ctx);
 pi_ctx_alloc_failure:
 	ib_dereg_mr(desc->data_mr);
+#endif /* CONFIG_COMPAT_SIGNATURE */
 fast_reg_mr_failure:
 	ib_free_fast_reg_page_list(desc->data_frpl);
 
@@ -438,12 +447,14 @@ void iser_free_fastreg_pool(struct iser_conn *ib_conn)
 		list_del(&desc->list);
 		ib_free_fast_reg_page_list(desc->data_frpl);
 		ib_dereg_mr(desc->data_mr);
+#if defined(CONFIG_COMPAT_SIGNATURE)
 		if (desc->pi_ctx) {
 			ib_free_fast_reg_page_list(desc->pi_ctx->prot_frpl);
 			ib_dereg_mr(desc->pi_ctx->prot_mr);
 			ib_destroy_mr(desc->pi_ctx->sig_mr);
 			kfree(desc->pi_ctx);
 		}
+#endif /* CONFIG_COMPAT_SIGNATURE */
 		kfree(desc);
 		++i;
 	}
@@ -490,12 +501,16 @@ static int iser_create_ib_conn_res(struct iser_conn *ib_conn)
 	init_attr.cap.max_recv_sge = 1;
 	init_attr.sq_sig_type	= IB_SIGNAL_REQ_WR;
 	init_attr.qp_type	= IB_QPT_RC;
+#if defined(CONFIG_COMPAT_SIGNATURE)
 	if (ib_conn->pi_support) {
 		init_attr.cap.max_send_wr = ISER_QP_SIG_MAX_REQ_DTOS;
 		init_attr.create_flags |= IB_QP_CREATE_SIGNATURE_EN;
 	} else {
 		init_attr.cap.max_send_wr  = ISER_QP_MAX_REQ_DTOS;
 	}
+#else
+	init_attr.cap.max_send_wr  = ISER_QP_MAX_REQ_DTOS;
+#endif /* !CONFIG_COMPAT_SIGNATURE */
 
 	ret = rdma_create_qp(ib_conn->cma_id, device->pd, &init_attr);
 	if (ret)
@@ -799,6 +814,7 @@ static void iser_addr_handler(struct rdma_cm_id *cma_id)
 
 	ib_conn->device = device;
 
+#if defined(CONFIG_COMPAT_SIGNATURE)
 	/* connection T10-PI support */
 	if (iser_pi_enable) {
 		if (!(device->dev_attr.device_cap_flags &
@@ -811,7 +827,9 @@ static void iser_addr_handler(struct rdma_cm_id *cma_id)
 			ib_conn->pi_support = true;
 		}
 	}
-
+#else
+	ib_conn->pi_support = false;
+#endif /* ! CONFIG_COMPAT_SIGNATURE */
 	ret = rdma_resolve_route(cma_id, 1000);
 	if (ret) {
 		iser_err("resolve route failed: %d\n", ret);
@@ -983,9 +1001,25 @@ int iser_connect(struct iser_conn   *ib_conn,
 
 	mutex_lock(&ib_conn->state_mutex);
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0))
 	sprintf(ib_conn->name, "%pISp", dst_addr);
 
 	iser_info("connecting to: %s\n", ib_conn->name);
+#else
+	if (dst_addr->sa_family == AF_INET6) {
+		struct sockaddr_in6 *addr = (struct sockaddr_in6 *) dst_addr;
+		sprintf(ib_conn->name, "[%pI6]:%d",
+			&(addr->sin6_addr),
+			ntohs(addr->sin6_port));
+        } else {
+		struct sockaddr_in *addr = (struct sockaddr_in *) dst_addr;
+		sprintf(ib_conn->name, "%pI4:%d",
+			&(addr->sin_addr.s_addr),
+			ntohs(addr->sin_port));
+	}
+
+	iser_info("connecting to: %s\n", ib_conn->name);
+#endif
 
 	/* the device is known only --after-- address resolution */
 	ib_conn->device = NULL;
@@ -1317,6 +1351,7 @@ static void iser_cq_callback(struct ib_cq *cq, void *cq_context)
 	tasklet_schedule(&device->cq_tasklet[cq_index]);
 }
 
+#if defined(CONFIG_COMPAT_SIGNATURE)
 u8 iser_check_task_pi_status(struct iscsi_iser_task *iser_task,
 			     enum iser_data_dir cmd_dir, sector_t *sector)
 {
@@ -1364,3 +1399,4 @@ err:
 	/* Not alot we can do here, return ambiguous guard error */
 	return 0x1;
 }
+#endif /* CONFIG_COMPAT_SIGNATURE */
