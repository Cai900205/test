/*
 * Copyright (C) Mellanox Technologies Ltd. 2001-2013.  ALL RIGHTS RESERVED.
 *
 * This software product is a proprietary product of Mellanox Technologies Ltd.
 * (the "Company") and all right, title, and interest in and to the software product,
 * including all associated intellectual property rights, are and shall
 * remain exclusively with the Company.
 *
 * This software is made available under either the GPL v2 license or a commercial license.
 * If you wish to obtain a commercial license, please contact Mellanox at support@mellanox.com.
 */

/*
* Move TX buffers & segmenents alloc and free from LWIP to VMA.
*/

--- orig_lwip/arch/lwipopts.h	2013-11-28 12:27:26.489928000 +0200
+++ lwip/arch/lwipopts.h	2013-12-01 08:50:13.419302000 +0200
@@ -114,7 +114,7 @@
 #ifdef _LWIP_MIN_MEM_MODE
 #define MEMP_NUM_PBUF                   30
 #else
-#define MEMP_NUM_PBUF                   1024
+#define MEMP_NUM_PBUF                   0 //1024
 #endif
 
 /**
@@ -134,13 +134,13 @@
  * MEMP_NUM_TCP_PCB: the number of simulatenously active TCP connections.
  * (requires the LWIP_TCP option)
  */
-#define MEMP_NUM_TCP_PCB               	32768 
+#define MEMP_NUM_TCP_PCB               	1 //32768
 
 /**
  * MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP connections.
  * (requires the LWIP_TCP option)
  */
-#define MEMP_NUM_TCP_PCB_LISTEN         1024
+#define MEMP_NUM_TCP_PCB_LISTEN         1 //1024
 
 /**
  * MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP segments.
@@ -150,7 +150,7 @@
 #ifdef _LWIP_MIN_MEM_MODE
 #define MEMP_NUM_TCP_SEG                64
 #else
-#define MEMP_NUM_TCP_SEG                16384
+#define MEMP_NUM_TCP_SEG                0 //16384
 #endif
 
 
@@ -256,14 +256,14 @@
  * this option does not affect outgoing packet sizes, which can be controlled
  * via IP_FRAG.
  */
-#define IP_REASSEMBLY                   1
+#define IP_REASSEMBLY                   0
 
 /**
  * IP_FRAG==1: Fragment outgoing IP packets if their size exceeds MTU. Note
  * that this option does not affect incoming packet sizes, which can be
  * controlled via IP_REASSEMBLY.
  */
-#define IP_FRAG                         1
+#define IP_FRAG                         0
 
 /**
  * IP_REASS_MAXAGE: Maximum time (in multiples of IP_TMR_INTERVAL - so seconds, normally)
@@ -379,7 +379,7 @@
 /**
  * LWIP_UDP==1: Turn on UDP.
  */
-#define LWIP_UDP                        1
+#define LWIP_UDP                        0
 
 /**
  * LWIP_UDPLITE==1: Turn on UDP-Lite. (Requires LWIP_UDP)
@@ -428,7 +428,7 @@
 #ifdef _LWIP_MIN_MEM_MODE
 #define TCP_SND_BUF                     4096 //256*1024
 #else
-#define TCP_SND_BUF                     100000 //256000
+#define TCP_SND_BUF                     1000000 //100000 //256000
 #endif
 
 #define TCP_SND_BUF_NO_NAGLE 256000
@@ -552,6 +552,7 @@
 #define LWIP_PLATFORM_HTONL(x) bswap_32(x)
 
 #define LWIP_3RD_PARTY_L3 1
+#define LWIP_3RD_PARTY_BUFS 1
 
 //debugging
 //#define ETHARP_DEBUG	LWIP_DBG_ON
--- orig_lwip/arch/lwippools.h	2013-11-28 12:27:26.461922000 +0200
+++ lwip/arch/lwippools.h	2013-11-25 15:25:19.840139000 +0200
@@ -6,13 +6,24 @@
  * LWIP_MALLOC_MEMPOOL(number_elements, element_size)
  */
 #if MEM_USE_POOLS
+/*
 #ifndef CUSTOM_POOL_SIZE
+// was 1544: we had to increase it to support tot_len in pbuf of 32 bit (instead of 16); TODO: try optimize size!
 #define CUSTOM_POOL_SIZE 1552
 #define CUSTOM_POOL_NUM  130000
 #define CUSTOM_POOL_NAME MEMP_POOL_##CUSTOM_POOL_SIZE
+LWIP_MALLOC_MEMPOOL_START
+LWIP_MALLOC_MEMPOOL(CUSTOM_POOL_NUM, CUSTOM_POOL_SIZE)
+LWIP_MALLOC_MEMPOOL_END
+#endif
+*/
+#ifndef CUSTOM_POOL_SIZE
+#define CUSTOM_POOL_SIZE 0
+#define CUSTOM_POOL_NUM  0
+#define CUSTOM_POOL_NAME MEMP_POOL_##CUSTOM_POOL_SIZE
 #endif
 LWIP_MALLOC_MEMPOOL_START
-LWIP_MALLOC_MEMPOOL(CUSTOM_POOL_NUM, CUSTOM_POOL_SIZE) // was 1544: we had to increase it to support tot_len in pbuf of 32 bit (instead of 16); TODO: try optimize size!
+LWIP_MALLOC_MEMPOOL(CUSTOM_POOL_NUM, CUSTOM_POOL_SIZE)
 LWIP_MALLOC_MEMPOOL_END
 #endif /* MEM_USE_POOLS */
 
--- orig_lwip/src/core/pbuf.c	2013-11-28 12:27:26.506927000 +0200
+++ lwip/src/core/pbuf.c	2013-12-01 08:33:32.977416000 +0200
@@ -522,6 +522,7 @@ pbuf_header(struct pbuf *p, s16_t header
   if (type == PBUF_RAM || type == PBUF_POOL) {
     /* set new payload pointer */
     p->payload = (u8_t *)p->payload - header_size_increment;
+#if !LWIP_3RD_PARTY_BUFS
     /* boundary check fails? */
     if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
       LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
@@ -532,6 +533,7 @@ pbuf_header(struct pbuf *p, s16_t header
       /* bail out unsuccesfully */
       return 1;
     }
+#endif
   /* pbuf types refering to external payloads? */
   } else if (type == PBUF_REF || type == PBUF_ROM) {
     /* hide a header in the payload? */
--- orig_lwip/src/core/tcp.c	2013-11-28 12:27:26.536924000 +0200
+++ lwip/src/core/tcp.c	2013-12-01 09:40:20.802939000 +0200
@@ -69,6 +69,36 @@ const char * const tcp_state_str[] = {
   "TIME_WAIT"   
 };
 
+#if LWIP_3RD_PARTY_BUFS
+tcp_tx_pbuf_alloc_fn external_tcp_tx_pbuf_alloc;
+
+void register_tcp_tx_pbuf_alloc(tcp_tx_pbuf_alloc_fn fn)
+{
+    external_tcp_tx_pbuf_alloc = fn;
+}
+
+tcp_tx_pbuf_free_fn external_tcp_tx_pbuf_free;
+
+void register_tcp_tx_pbuf_free(tcp_tx_pbuf_free_fn fn)
+{
+    external_tcp_tx_pbuf_free = fn;
+}
+
+tcp_seg_alloc_fn external_tcp_seg_alloc;
+
+void register_tcp_seg_alloc(tcp_seg_alloc_fn fn)
+{
+    external_tcp_seg_alloc = fn;
+}
+
+tcp_seg_free_fn external_tcp_seg_free;
+
+void register_tcp_seg_free(tcp_seg_free_fn fn)
+{
+    external_tcp_seg_free = fn;
+}
+#endif
+
 enum cc_algo_mod lwip_cc_algo_module = CC_MOD_LWIP;
 
 u16_t lwip_tcp_mss = CONST_TCP_MSS;
@@ -343,14 +373,14 @@ tcp_abandon(struct tcp_pcb *pcb, int res
     errf_arg = pcb->my_container;
     tcp_pcb_remove(pcb);
     if (pcb->unacked != NULL) {
-      tcp_segs_free(pcb->unacked);
+      tcp_tx_segs_free(pcb, pcb->unacked);
     }
     if (pcb->unsent != NULL) {
-      tcp_segs_free(pcb->unsent);
+      tcp_tx_segs_free(pcb, pcb->unsent);
     }
 #if TCP_QUEUE_OOSEQ    
     if (pcb->ooseq != NULL) {
-      tcp_segs_free(pcb->ooseq);
+      tcp_segs_free(pcb, pcb->ooseq);
     }
 #endif /* TCP_QUEUE_OOSEQ */
     TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
@@ -801,7 +831,7 @@ tcp_slowtmr(struct tcp_pcb* pcb)
 #if TCP_QUEUE_OOSEQ
 	if (pcb->ooseq != NULL &&
 		(u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
-	  tcp_segs_free(pcb->ooseq);
+	  tcp_segs_free(pcb, pcb->ooseq);
 	  pcb->ooseq = NULL;
 	  LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
 	}
@@ -921,11 +951,12 @@ tcp_fasttmr(struct tcp_pcb* pcb)
  * @param seg tcp_seg list of TCP segments to free
  */
 void
-tcp_segs_free(struct tcp_seg *seg)
+tcp_segs_free(struct tcp_pcb *pcb, struct tcp_seg *seg)
 {
   while (seg != NULL) {
     struct tcp_seg *next = seg->next;
-    tcp_seg_free(seg);
+    seg->next = NULL;
+    tcp_seg_free(pcb, seg);
     seg = next;
   }
 }
@@ -936,7 +967,7 @@ tcp_segs_free(struct tcp_seg *seg)
  * @param seg single tcp_seg to free
  */
 void
-tcp_seg_free(struct tcp_seg *seg)
+tcp_seg_free(struct tcp_pcb *pcb, struct tcp_seg *seg)
 {
   if (seg != NULL) {
     if (seg->p != NULL) {
@@ -945,7 +976,50 @@ tcp_seg_free(struct tcp_seg *seg)
       seg->p = NULL;
 #endif /* TCP_DEBUG */
     }
+#if LWIP_3RD_PARTY_BUFS
+    external_tcp_seg_free(pcb, seg);
+#else
+    memp_free(MEMP_TCP_SEG, seg);
+#endif
+  }
+}
+
+/**
+ * Deallocates a list of TCP segments (tcp_seg structures).
+ *
+ * @param seg tcp_seg list of TCP segments to free
+ */
+void
+tcp_tx_segs_free(struct tcp_pcb * pcb, struct tcp_seg *seg)
+{
+  while (seg != NULL) {
+    struct tcp_seg *next = seg->next;
+    seg->next = NULL;
+    tcp_tx_seg_free(pcb, seg);
+    seg = next;
+  }
+}
+
+/**
+ * Frees a TCP segment (tcp_seg structure).
+ *
+ * @param seg single tcp_seg to free
+ */
+void
+tcp_tx_seg_free(struct tcp_pcb * pcb, struct tcp_seg *seg)
+{
+  if (seg != NULL) {
+    if (seg->p != NULL) {
+      tcp_tx_pbuf_free(pcb, seg->p);
+#if TCP_DEBUG
+      seg->p = NULL;
+#endif /* TCP_DEBUG */
+    }
+#if LWIP_3RD_PARTY_BUFS
+    external_tcp_seg_free(pcb, seg);
+#else
     memp_free(MEMP_TCP_SEG, seg);
+#endif
   }
 }
 
@@ -970,11 +1044,15 @@ tcp_setprio(struct tcp_pcb *pcb, u8_t pr
  * @return a copy of seg
  */ 
 struct tcp_seg *
-tcp_seg_copy(struct tcp_seg *seg)
+tcp_seg_copy(struct tcp_pcb* pcb, struct tcp_seg *seg)
 {
   struct tcp_seg *cseg;
 
+#if LWIP_3RD_PARTY_BUFS
+  cseg = external_tcp_seg_alloc(pcb);
+#else
   cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
+#endif
   if (cseg == NULL) {
     return NULL;
   }
@@ -1167,6 +1245,47 @@ tcp_alloc(u8_t prio)
   return pcb;
 }
 
+struct pbuf *
+tcp_tx_pbuf_alloc(struct tcp_pcb * pcb, pbuf_layer layer, u16_t length, pbuf_type type)
+{
+#if LWIP_3RD_PARTY_BUFS
+	if (type == PBUF_RAM) {
+		struct pbuf * p = external_tcp_tx_pbuf_alloc(pcb);
+		if (!p) return NULL;
+		/* Set up internal structure of the pbuf. */
+		p->len = p->tot_len = length;
+		p->next = NULL;
+		p->type = type;
+		/* set reference count */
+		p->ref = 1;
+		/* set flags */
+		p->flags = 0;
+		return p;
+	}
+#endif
+	return pbuf_alloc(layer, length, type);
+}
+
+void
+tcp_tx_pbuf_free(struct tcp_pcb * pcb, struct pbuf * p)
+{
+#if LWIP_3RD_PARTY_BUFS
+	struct pbuf * p_next = NULL;
+	while (p) {
+		p_next = p->next;
+		p->next = NULL;
+		if (p->type  == PBUF_RAM) {
+			external_tcp_tx_pbuf_free(pcb, p);
+		} else {
+			pbuf_free(p);
+		}
+		p = p_next;
+	}
+#else
+	pbuf_free(p);
+#endif
+}
+
 /**
  * Creates a new TCP protocol control block but doesn't place it on
  * any of the TCP PCB lists.
@@ -1349,7 +1468,7 @@ tcp_pcb_purge(struct tcp_pcb *pcb)
     if (pcb->ooseq != NULL) {
       LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
     }
-    tcp_segs_free(pcb->ooseq);
+    tcp_segs_free(pcb, pcb->ooseq);
     pcb->ooseq = NULL;
 #endif /* TCP_QUEUE_OOSEQ */
 
@@ -1357,8 +1476,8 @@ tcp_pcb_purge(struct tcp_pcb *pcb)
        queue if it fires */
     pcb->rtime = -1;
 
-    tcp_segs_free(pcb->unsent);
-    tcp_segs_free(pcb->unacked);
+    tcp_tx_segs_free(pcb, pcb->unsent);
+    tcp_tx_segs_free(pcb, pcb->unacked);
     pcb->unacked = pcb->unsent = NULL;
 #if TCP_OVERSIZE
     pcb->unsent_oversize = 0;
--- orig_lwip/src/core/tcp_in.c	2013-11-28 12:27:26.551927000 +0200
+++ lwip/src/core/tcp_in.c	2013-11-26 14:15:32.492728000 +0200
@@ -938,7 +938,7 @@ tcp_process(struct tcp_pcb *pcb, tcp_in_
         pcb->nrtx = 0;
       }
 
-      tcp_seg_free(rseg);
+      tcp_tx_seg_free(pcb, rseg);
 
       /* Call the user specified function to call when sucessfully
        * connected. */
@@ -1073,13 +1073,13 @@ tcp_process(struct tcp_pcb *pcb, tcp_in_
  * Called from tcp_receive()
  */
 static void
-tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next, tcp_in_data* in_data)
+tcp_oos_insert_segment(struct tcp_pcb *pcb, struct tcp_seg *cseg, struct tcp_seg *next, tcp_in_data* in_data)
 {
   struct tcp_seg *old_seg;
 
   if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
     /* received segment overlaps all following segments */
-    tcp_segs_free(next);
+    tcp_segs_free(pcb, next);
     next = NULL;
   }
   else {
@@ -1094,7 +1094,7 @@ tcp_oos_insert_segment(struct tcp_seg *c
       }
       old_seg = next;
       next = next->next;
-      tcp_seg_free(old_seg);
+      tcp_seg_free(pcb, old_seg);
     }
     if (next &&
         TCP_SEQ_GT(in_data->seqno + cseg->len, next->tcphdr->seqno)) {
@@ -1329,7 +1329,7 @@ tcp_receive(struct tcp_pcb *pcb, tcp_in_
         }
 
         pcb->snd_queuelen -= pbuf_clen(next->p);
-        tcp_seg_free(next);
+        tcp_tx_seg_free(pcb, next);
 #if TCP_RCVSCALE
         LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U32_F" (after freeing unacked)\n", (u32_t)pcb->snd_queuelen));
 #else
@@ -1378,7 +1378,7 @@ tcp_receive(struct tcp_pcb *pcb, tcp_in_
         pcb->acked--;
       }
       pcb->snd_queuelen -= pbuf_clen(next->p);
-      tcp_seg_free(next);
+      tcp_tx_seg_free(pcb, next);
 #if TCP_RCVSCALE
       LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u32_t)pcb->snd_queuelen));
 #else
@@ -1566,7 +1566,7 @@ tcp_receive(struct tcp_pcb *pcb, tcp_in_
             while (pcb->ooseq != NULL) {
               struct tcp_seg *old_ooseq = pcb->ooseq;
               pcb->ooseq = pcb->ooseq->next;
-              tcp_seg_free(old_ooseq);
+              tcp_seg_free(pcb, old_ooseq);
             }
           }
           else {
@@ -1584,7 +1584,7 @@ tcp_receive(struct tcp_pcb *pcb, tcp_in_
               }
               prev = next;
               next = next->next;
-              tcp_seg_free(prev);
+              tcp_seg_free(pcb, prev);
             }
             /* Now trim right side of inseg if it overlaps with the first
              * segment on ooseq */
@@ -1670,7 +1670,7 @@ tcp_receive(struct tcp_pcb *pcb, tcp_in_
           }
 
           pcb->ooseq = cseg->next;
-          tcp_seg_free(cseg);
+          tcp_seg_free(pcb, cseg);
         }
 #endif /* TCP_QUEUE_OOSEQ */
 
@@ -1688,7 +1688,7 @@ tcp_receive(struct tcp_pcb *pcb, tcp_in_
 #if TCP_QUEUE_OOSEQ
         /* We queue the segment on the ->ooseq queue. */
         if (pcb->ooseq == NULL) {
-          pcb->ooseq = tcp_seg_copy(&in_data->inseg);
+          pcb->ooseq = tcp_seg_copy(pcb, &in_data->inseg);
         } else {
           /* If the queue is not empty, we walk through the queue and
              try to find a place where the sequence number of the
@@ -1713,14 +1713,14 @@ tcp_receive(struct tcp_pcb *pcb, tcp_in_
                 /* The incoming segment is larger than the old
                    segment. We replace some segments with the new
                    one. */
-                cseg = tcp_seg_copy(&in_data->inseg);
+                cseg = tcp_seg_copy(pcb, &in_data->inseg);
                 if (cseg != NULL) {
                   if (prev != NULL) {
                     prev->next = cseg;
                   } else {
                     pcb->ooseq = cseg;
                   }
-                  tcp_oos_insert_segment(cseg, next, in_data);
+                  tcp_oos_insert_segment(pcb, cseg, next, in_data);
                 }
                 break;
               } else {
@@ -1736,10 +1736,10 @@ tcp_receive(struct tcp_pcb *pcb, tcp_in_
                      than the sequence number of the first segment on the
                      queue. We put the incoming segment first on the
                      queue. */
-                  cseg = tcp_seg_copy(&in_data->inseg);
+                  cseg = tcp_seg_copy(pcb, &in_data->inseg);
                   if (cseg != NULL) {
                     pcb->ooseq = cseg;
-                    tcp_oos_insert_segment(cseg, next, in_data);
+                    tcp_oos_insert_segment(pcb, cseg, next, in_data);
                   }
                   break;
                 }
@@ -1752,7 +1752,7 @@ tcp_receive(struct tcp_pcb *pcb, tcp_in_
                      the next segment on ->ooseq. We trim trim the previous
                      segment, delete next segments that included in received segment
                      and trim received, if needed. */
-                  cseg = tcp_seg_copy(&in_data->inseg);
+                  cseg = tcp_seg_copy(pcb, &in_data->inseg);
                   if (cseg != NULL) {
                     if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, in_data->seqno)) {
                       /* We need to trim the prev segment. */
@@ -1760,7 +1760,7 @@ tcp_receive(struct tcp_pcb *pcb, tcp_in_
                       pbuf_realloc(prev->p, prev->len);
                     }
                     prev->next = cseg;
-                    tcp_oos_insert_segment(cseg, next, in_data);
+                    tcp_oos_insert_segment(pcb, cseg, next, in_data);
                   }
                   break;
                 }
@@ -1774,7 +1774,7 @@ tcp_receive(struct tcp_pcb *pcb, tcp_in_
                   /* segment "next" already contains all data */
                   break;
                 }
-                next->next = tcp_seg_copy(&in_data->inseg);
+                next->next = tcp_seg_copy(pcb, &in_data->inseg);
                 if (next->next != NULL) {
                   if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, in_data->seqno)) {
                     /* We need to trim the last segment. */
--- orig_lwip/src/core/tcp_out.c	2013-11-28 12:27:26.554926000 +0200
+++ lwip/src/core/tcp_out.c	2013-12-01 08:37:21.744072000 +0200
@@ -109,7 +109,7 @@ tcp_output_alloc_header(struct tcp_pcb *
                       u32_t seqno_be /* already in network byte order */)
 {
   struct tcp_hdr *tcphdr;
-  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
+  struct pbuf *p = tcp_tx_pbuf_alloc(pcb, PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
   if (p != NULL) {
     LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                  (p->len >= TCP_HLEN + optlen));
@@ -179,9 +179,13 @@ tcp_create_segment(struct tcp_pcb *pcb, 
   struct tcp_seg *seg;
   u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
 
+#if LWIP_3RD_PARTY_BUFS
+  if ((seg = external_tcp_seg_alloc(pcb)) == NULL) {
+#else
   if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
+#endif
     LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
-    pbuf_free(p);
+    tcp_tx_pbuf_free(pcb, p);
     return NULL;
   }
   seg->flags = optflags;
@@ -205,7 +209,7 @@ tcp_create_segment(struct tcp_pcb *pcb, 
   if (pbuf_header(p, TCP_HLEN)) {
     LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
     TCP_STATS_INC(tcp.err);
-    tcp_seg_free(seg);
+    tcp_tx_seg_free(pcb, seg);
     return NULL;
   }
   seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
@@ -272,7 +276,7 @@ tcp_pbuf_prealloc(pbuf_layer layer, u16_
     }
   }
 #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
-  p = pbuf_alloc(layer, alloc, PBUF_RAM);
+  p = tcp_tx_pbuf_alloc(pcb, layer, alloc, PBUF_RAM);
   if (p == NULL) {
     return NULL;
   }
@@ -520,7 +524,7 @@ tcp_write(struct tcp_pcb *pcb, const voi
 #endif /* TCP_CHECKSUM_ON_COPY */
       } else {
         /* Data is not copied */
-        if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
+        if ((concat_p = tcp_tx_pbuf_alloc(pcb, PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
           LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
                       ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
           goto memerr;
@@ -597,7 +601,7 @@ tcp_write(struct tcp_pcb *pcb, const voi
       if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
         /* If allocation fails, we have to deallocate the data pbuf as
          * well. */
-        pbuf_free(p2);
+        tcp_tx_pbuf_free(pcb, p2);
         LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for header pbuf\n"));
         goto memerr;
       }
@@ -616,7 +620,7 @@ tcp_write(struct tcp_pcb *pcb, const voi
 #else
       LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: queue too long %"U16_F" (%"U16_F")\n", queuelen, pcb->max_unsent_len));
 #endif
-      pbuf_free(p);
+      tcp_tx_pbuf_free(pcb, p);
       goto memerr;
     }
 
@@ -735,10 +739,10 @@ memerr:
   TCP_STATS_INC(tcp.memerr);
 
   if (concat_p != NULL) {
-    pbuf_free(concat_p);
+    tcp_tx_pbuf_free(pcb, concat_p);
   }
   if (queue != NULL) {
-    tcp_segs_free(queue);
+    tcp_tx_segs_free(pcb, queue);
   }
   if (pcb->snd_queuelen != 0) {
     LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
@@ -804,7 +808,7 @@ tcp_enqueue_flags(struct tcp_pcb *pcb, u
   }
 
   /* Allocate pbuf with room for TCP header + options */
-  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
+  if ((p = tcp_tx_pbuf_alloc(pcb, PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
     pcb->flags |= TF_NAGLEMEMERR;
     TCP_STATS_INC(tcp.memerr);
     return ERR_MEM;
@@ -930,7 +934,7 @@ tcp_send_empty_ack(struct tcp_pcb *pcb)
 #else /* LWIP_NETIF_HWADDRHINT*/
   ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP);
 #endif /* LWIP_NETIF_HWADDRHINT*/
-  pbuf_free(p);
+  tcp_tx_pbuf_free(pcb, p);
 
   return ERR_OK;
 }
@@ -1075,7 +1079,7 @@ tcp_output(struct tcp_pcb *pcb)
       }
     /* do not queue empty segments on the unacked list */
     } else {
-      tcp_seg_free(seg);
+      tcp_tx_seg_free(pcb, seg);
     }
     seg = pcb->unsent;
   }
@@ -1267,7 +1271,7 @@ tcp_rst(u32_t seqno, u32_t ackno,
 {
   struct pbuf *p;
   struct tcp_hdr *tcphdr;
-  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
+  p = tcp_tx_pbuf_alloc(pcb, PBUF_IP, TCP_HLEN, PBUF_RAM);
   if (p == NULL) {
       LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
       return;
@@ -1302,7 +1306,7 @@ tcp_rst(u32_t seqno, u32_t ackno,
 #else /* LWIP_NETIF_HWADDRHINT*/
   ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
 #endif
-  pbuf_free(p);
+  tcp_tx_pbuf_free(pcb, p);
   LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
 }
 
@@ -1471,7 +1475,7 @@ tcp_keepalive(struct tcp_pcb *pcb)
   ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
 #endif /* LWIP_NETIF_HWADDRHINT*/
 
-  pbuf_free(p);
+  tcp_tx_pbuf_free(pcb, p);
 
   LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                           pcb->snd_nxt - 1, pcb->rcv_nxt));
@@ -1550,7 +1554,7 @@ tcp_zero_window_probe(struct tcp_pcb *pc
   ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
 #endif /* LWIP_NETIF_HWADDRHINT*/
 
-  pbuf_free(p);
+  tcp_tx_pbuf_free(pcb, p);
 
   LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                           " ackno %"U32_F".\n",
--- orig_lwip/src/include/lwip/pbuf.h	2013-11-28 12:27:26.429923000 +0200
+++ lwip/src/include/lwip/pbuf.h	2013-11-26 13:25:17.722238000 +0200
@@ -42,7 +42,8 @@ extern "C" {
 
 /** Currently, the pbuf_custom code is only needed for one specific configuration
  * of IP_FRAG */
-#define LWIP_SUPPORT_CUSTOM_PBUF (IP_FRAG && !IP_FRAG_USES_STATIC_BUF && !LWIP_NETIF_TX_SINGLE_PBUF)
+//#define LWIP_SUPPORT_CUSTOM_PBUF (IP_FRAG && !IP_FRAG_USES_STATIC_BUF && !LWIP_NETIF_TX_SINGLE_PBUF)
+#define LWIP_SUPPORT_CUSTOM_PBUF 1
 
 #define PBUF_TRANSPORT_HLEN 20
 #define PBUF_IP_HLEN        20
--- .orig_lwip/src/include/lwip/tcp.h	2013-11-28 12:27:26.560932000 +0200
+++ lwip/src/include/lwip/tcp.h	2013-12-01 08:43:42.178154000 +0200
@@ -59,6 +59,30 @@ void register_ip_route_mtu(ip_route_mtu_
 
 #endif
 
+#if LWIP_3RD_PARTY_BUFS
+typedef struct pbuf * (*tcp_tx_pbuf_alloc_fn)(void* p_conn);
+
+void register_tcp_tx_pbuf_alloc(tcp_tx_pbuf_alloc_fn fn);
+
+typedef void (*tcp_tx_pbuf_free_fn)(void* p_conn, struct pbuf * p);
+
+void register_tcp_tx_pbuf_free(tcp_tx_pbuf_free_fn fn);
+
+typedef struct tcp_seg * (*tcp_seg_alloc_fn)(void* p_conn);
+
+void register_tcp_seg_alloc(tcp_seg_alloc_fn fn);
+
+typedef void (*tcp_seg_free_fn)(void* p_conn, struct tcp_seg * seg);
+
+void register_tcp_seg_free(tcp_seg_free_fn fn);
+
+
+extern tcp_tx_pbuf_alloc_fn external_tcp_tx_pbuf_alloc;
+extern tcp_tx_pbuf_free_fn external_tcp_tx_pbuf_free;
+extern tcp_seg_alloc_fn external_tcp_seg_alloc;
+extern tcp_seg_free_fn external_tcp_seg_free;
+#endif
+
 
 struct tcp_pcb;
 
--- orig_lwip/src/include/lwip/tcp_impl.h	2013-11-28 12:27:26.445926000 +0200
+++ lwip/src/include/lwip/tcp_impl.h	2013-12-01 08:44:41.233086000 +0200
@@ -68,6 +68,8 @@ void             L3_level_tcp_input   (s
 #endif
 /* Used within the TCP code only: */
 struct tcp_pcb * tcp_alloc   (u8_t prio);
+struct pbuf *    tcp_tx_pbuf_alloc(struct tcp_pcb * pcb, pbuf_layer layer, u16_t length, pbuf_type type);
+void		 tcp_tx_pbuf_free(struct tcp_pcb * pcb, struct pbuf * pbuf);
 void             tcp_abandon (struct tcp_pcb *pcb, int reset);
 err_t            tcp_send_empty_ack(struct tcp_pcb *pcb);
 void             tcp_rexmit  (struct tcp_pcb *pcb);
@@ -431,9 +433,11 @@ struct tcp_pcb *tcp_pcb_copy(struct tcp_
 void tcp_pcb_purge(struct tcp_pcb *pcb);
 void tcp_pcb_remove(struct tcp_pcb *pcb);
 
-void tcp_segs_free(struct tcp_seg *seg);
-void tcp_seg_free(struct tcp_seg *seg);
-struct tcp_seg *tcp_seg_copy(struct tcp_seg *seg);
+void tcp_segs_free(struct tcp_pcb *pcb, struct tcp_seg *seg);
+void tcp_seg_free(struct tcp_pcb *pcb, struct tcp_seg *seg);
+void tcp_tx_segs_free(struct tcp_pcb * pcb, struct tcp_seg *seg);
+void tcp_tx_seg_free(struct tcp_pcb * pcb, struct tcp_seg *seg);
+struct tcp_seg *tcp_seg_copy(struct tcp_pcb* pcb, struct tcp_seg *seg);
 
 #define tcp_ack(pcb)                               \
   do {                                             \
--- orig_lwip/src/Makefile.am	2013-11-28 12:27:26.562928000 +0200
+++ lwip/src/Makefile.am	2013-11-27 17:09:18.521729000 +0200
@@ -24,7 +24,7 @@ NETIFFILES=$(LWIPDIR)/netif/etharp.c
 
 CFLAGS=
 liblwip_la_CFLAGS = \
-	-Wall -g -O3 $(LDFLAGS) -DIPv4 -DLWIP_DEBUG -fPIC \
+	-Wall -g -O3 $(LDFLAGS) -DIPv4 -fPIC \
 	-I$(LWIPDIR)/include -I$(LWIPDIR)/include/ipv4 \
         -I$(LWIPDIR) -I. -I$(LWIPDIR)/../arch -I.. 
 	
 
